<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>鼓手即時 BPM 偵測與視覺化</title>
  <style>
    body {
      font-family: "Noto Sans TC", sans-serif;
      background: #0f1720;
      color: #e6eef8;
      margin: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h2 {
      font-size: clamp(1.4rem, 4vw, 2rem);
      text-align: center;
    }

    button {
      padding: 10px 20px;
      border: 0;
      border-radius: 8px;
      background: #2563eb;
      color: white;
      cursor: pointer;
      font-size: clamp(0.9rem, 2vw, 1.2rem);
      margin-top: 10px;
    }

    #bpm {
      font-size: clamp(1.8rem, 5vw, 2.8rem);
      margin-top: 14px;
      text-align: center;
    }

    .small {
      color: #99b3d6;
      font-size: clamp(0.8rem, 2vw, 1rem);
      max-width: 600px;
      text-align: center;
      margin-top: 8px;
      line-height: 1.5;
    }

    canvas {
      background: #071023;
      border-radius: 8px;
      width: 90vw;
      max-width: 900px;
      height: 240px;
      margin-top: 14px;
    }

    #beatDot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #1e3a8a;
      margin-top: 12px;
      transition: background 0.1s, box-shadow 0.1s;
    }

    #beatDot.active {
      background: #60a5fa;
      box-shadow: 0 0 15px #3b82f6;
    }
  </style>
</head>
<body>
  <h2>🥁 鼓手即時 BPM 偵測與視覺化</h2>
  <button id="startBtn">開始</button>
  <div class="small">建議用近距離麥克風（靠近小鼓或地鼓），每打一下會即時顯示 BPM</div>
  <div id="bpm">BPM：<span id="bpmVal">--</span></div>
  <div id="beatDot"></div>
  <canvas id="canvas"></canvas>

<script>
(async function(){
  const startBtn = document.getElementById('startBtn');
  const bpmVal = document.getElementById('bpmVal');
  const beatDot = document.getElementById('beatDot');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas(){
    const w = canvas.clientWidth;
    const h = 240;
    const ratio = window.devicePixelRatio || 1;
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  let audioCtx, micStream, processor;
  let onsetTimestamps = [];
  let lastPeakTime = 0;
  const historySeconds = 20;

  startBtn.onclick = async ()=> {
    if (!audioCtx) await startAudio();
    else stopAudio();
  };

  async function startAudio(){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micStream = audioCtx.createMediaStreamSource(stream);
    processor = audioCtx.createScriptProcessor(512, 1, 1);
    micStream.connect(processor);
    processor.connect(audioCtx.destination);
    processor.onaudioprocess = e => {
      const buf = e.inputBuffer.getChannelData(0);
      processAudio(buf, audioCtx.currentTime);
    };
    requestAnimationFrame(drawLoop);
    startBtn.textContent = "停止";
  }

  function stopAudio(){
    if (processor) processor.disconnect();
    if (micStream) micStream.disconnect();
    if (audioCtx) audioCtx.close();
    audioCtx = null;
    startBtn.textContent = "開始";
    bpmVal.textContent = "--";
    onsetTimestamps = [];
  }

  function processAudio(buf, time){
    let sum = 0;
    for (let i=0; i<buf.length; i++) sum += buf[i]*buf[i];
    const rms = Math.sqrt(sum / buf.length);
    const now = time;

    if (!processAudio.energyHistory) processAudio.energyHistory = [];
    processAudio.energyHistory.push({t:now, e:rms});
    while (processAudio.energyHistory.length && now - processAudio.energyHistory[0].t > 2)
      processAudio.energyHistory.shift();

    const energies = processAudio.energyHistory.map(o=>o.e);
    const baseline = median(energies);
    const std = stddev(energies);
    const threshold = baseline + Math.max(0.001, std*1.2);

    if (rms > threshold && (now - lastPeakTime) > 0.06){
      const lastFew = energies.slice(-4);
      if (rms >= Math.max(...lastFew)){
        lastPeakTime = now;
        registerOnset(now);
      }
    }
  }

  function registerOnset(t){
    onsetTimestamps.push(t);
    while (onsetTimestamps.length && (t - onsetTimestamps[0]) > historySeconds)
      onsetTimestamps.shift();

    beatDot.classList.add("active");
    setTimeout(()=>beatDot.classList.remove("active"), 100);

    if (onsetTimestamps.length >= 2){
      const intervals = [];
      for (let i = onsetTimestamps.length - 1; i > 0 && intervals.length < 8; i--){
        intervals.push(onsetTimestamps[i] - onsetTimestamps[i-1]);
      }
      const avgInterval = intervals.reduce((a,b)=>a+b,0)/intervals.length;
      const bpm = 60 / avgInterval;
      if (bpm >= 40 && bpm <= 240){
        bpmVal.textContent = bpm.toFixed(1);
      }
    }
  }

  function drawLoop(){
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    ctx.fillStyle = "#071023";
    ctx.fillRect(0, 0, w, h);

    ctx.strokeStyle = "#12304b";
    for (let i=0;i<4;i++){
      const y = h*(i+1)/5;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }

    requestAnimationFrame(drawLoop);
  }

  function median(arr){
    if (!arr.length) return 0;
    const sorted = arr.slice().sort((a,b)=>a-b);
    const m = Math.floor(sorted.length/2);
    return sorted.length % 2 ? sorted[m] : (sorted[m-1]+sorted[m])/2;
  }
  function stddev(arr){
    if (!arr.length) return 0;
    const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
    const v = arr.reduce((s,x)=>s+(x-mean)**2,0)/arr.length;
    return Math.sqrt(v);
  }
})();
</script>
</body>
</html>
